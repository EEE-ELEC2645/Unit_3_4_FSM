// ELEC2645 Finite State Machine (FSM) Demo
// =========================================
// This example demonstrates the fundamental concept of finite state machines (FSM).
// 
// KEY CONCEPT: The system has multiple "states", and the SAME INPUT produces DIFFERENT
// OUTPUTS depending on which state the system is in.
//
// How it works:
// 1. Press the joystick button to change states (interrupt triggers state transition)
// 2. Move the joystick in each state to see different behaviors
// 3. The main loop reads the joystick and calls different handlers based on current state
//
// The Four States:
// - STATE_CIRCLES: Joystick controls circle color (X) and size (Y) - analog input
// - STATE_RECTANGLES: Joystick moves a rectangle around the screen - analog input
// - STATE_LINES: Joystick draws a line from center (direction and length) - analog input
// - STATE_SPRITES: Joystick moves a sprite in 8 directions - discrete/digital input


// STM32 HAL headers (auto-generated by STM32CubeMX)
#include "main.h"
#include "tim.h"       // Timer 2 for PWM buzzer control
#include "usart.h"     // For serial output
#include "gpio.h"      // GPIO control
#include "adc.h"       // ADC for joystick input

// AUTO-GENERATED STM32 FUNCTION PROTOTYPES - DO NOT EDIT
void SystemClock_Config(void);
void PeriphCommonClock_Config(void);

// Buzzer library
#include "Buzzer.h" // Not used but included for completeness and future expansion of the demo to include buzzer functionality
#include "PWM.h"    // For PWM control of the LED 
#include "LCD.h"  // For LCD demonstration 
#include "Joystick.h" // include the Joystick driver functions

#include <stdint.h>
#include <stdio.h>
#include <math.h>

// ===== BUZZER CONFIGURATION =====
// Configure buzzer to use TIM2 Channel 3 (current hardware setup)
Buzzer_cfg_t buzzer_cfg = {
    .htim = &htim2,
    .channel = TIM_CHANNEL_3,
    .tick_freq_hz = 1000000,  // 1MHz timer clock (prescaler = 79 with 80MHz input)
    .min_freq_hz = 20,
    .max_freq_hz = 20000,
    .setup_done = 0
};

// ===== LCD CONFIGURATION =====
ST7789V2_cfg_t cfg0 = {
    .setup_done = 0,
    .spi = SPI2,
    .RST = {.port = GPIOB, .pin = GPIO_PIN_2},
    .BL = {.port = GPIOB, .pin = GPIO_PIN_1},
    .DC = {.port = GPIOB, .pin = GPIO_PIN_11},
    .CS = {.port = GPIOB, .pin = GPIO_PIN_12},
    .MOSI = {.port = GPIOB, .pin = GPIO_PIN_15},
    .SCLK = {.port = GPIOB, .pin = GPIO_PIN_13},
    .dma = {.instance = DMA1, .channel = DMA1_Channel5}
};

// ===== JOYSTICK CONFIGURATION =====
Joystick_cfg_t joystick_cfg = {
    .adc = &hadc1,
    .x_channel = ADC_CHANNEL_1, //A5 on Nucleo board
    .y_channel = ADC_CHANNEL_2, //A4 on Nucleo board
    .sampling_time = ADC_SAMPLETIME_47CYCLES_5,
    .center_x = JOYSTICK_DEFAULT_CENTER_X,
    .center_y = JOYSTICK_DEFAULT_CENTER_Y,
    .deadzone = JOYSTICK_DEADZONE,
    .setup_done = 0
};

// Joystick data structure to hold readings
Joystick_t joystick_data;

// ===== PWM CONFIGURATION =====
// Configure PWM to use TIM4 Channel 1 (current hardware setup)
PWM_cfg_t pwm_cfg = {
    .htim = &htim4,
    .channel = TIM_CHANNEL_1,
    .tick_freq_hz = 1000000,  // 1MHz timer clock (prescaler = 79 with 80MHz input)
    .min_freq_hz = 10,
    .max_freq_hz = 50000,
    .setup_done = 0
};

// ===== FSM STATE DEFINITIONS =====

/**
 * @brief FSM States - Each state provides a different interactive experience
 */
typedef enum {
    STATE_CIRCLES = 0,      // Circle drawing mode: joystick controls color and size
    STATE_RECTANGLES,       // Rectangle mode: joystick controls position
    STATE_LINES,            // Line drawing mode: joystick controls direction
    STATE_SPRITES           // Sprite mode: joystick moves sprite around
} FSM_State_t;

// Total number of states (used for wrapping)
#define STATE_COUNT 4

// State names for display
const char* state_names[] = {
    "CIRCLES",
    "RECTANGLES",
    "LINES",
    "SPRITES"
};

// ===== SPRITE DEFINITIONS =====
// 10x10 face sprite for STATE_SPRITES
// This sprite has either 255 (transparent) or 0 (LCD_COLOUR_0/black)
const uint8_t Face[10][10] = {
    {255, 255, 0, 0, 0, 0, 0, 0, 255, 255 },
    { 255, 0, 0, 255, 255, 255, 255, 0, 0, 255 },
    { 0, 0, 255, 255, 255, 255, 255, 255, 0, 0 },
    { 0, 255, 255, 0, 255, 255, 0, 255, 255, 0 },
    { 0, 255, 255, 255, 255, 255, 255, 255, 255, 0 },
    { 0, 255, 0, 255, 255, 255, 255, 0, 255, 0 },
    { 0, 255, 255, 0, 0, 0, 0, 255, 255, 0 },
    { 0, 0, 255, 255, 255, 255, 255, 255, 0, 0 },
    { 255, 0, 0, 255, 255, 255, 255, 0, 0, 255 },
    { 255, 255, 0, 0, 0, 0, 0, 0, 255, 255 }
};

// ===== UTILITY FUNCTIONS =====

/**
 * @brief Redirect printf to UART for debugging
 */
int _write(int file, char *ptr, int len) {
    HAL_UART_Transmit(&huart2, (uint8_t*)ptr, len, HAL_MAX_DELAY);
    return len;
}

// ===== FSM Variables =====

// Current FSM state (volatile because it's modified in interrupt handler)
// This variable determines which state handler function gets called in the main loop
volatile FSM_State_t current_state = STATE_CIRCLES;

// Flag to indicate state has changed (set by interrupt, cleared in main loop)
// Used to trigger the state info display when transitioning between states
volatile uint8_t state_changed = 1;

// Debounce delay in milliseconds - prevents multiple triggers from single button press
#define DEBOUNCE_DELAY 200

// ===== STATE HANDLER FUNCTION PROTOTYPES =====
void handle_state_circles(Joystick_t* joy);
void handle_state_rectangles(Joystick_t* joy);
void handle_state_lines(Joystick_t* joy);
void handle_state_sprites(Joystick_t* joy);
void display_state_info(void);

// ===== Main Function =====

/**
  * @brief  The application entry point - Finite State Machine Demo
  * @retval int
  */
int main(void)
{
    /* MCU Configuration */
    HAL_Init();
    SystemClock_Config();
    PeriphCommonClock_Config();

    /* Initialize peripherals */
    MX_GPIO_Init();
    MX_USART2_UART_Init();
    MX_ADC1_Init();  // Initialize ADC for joystick
    
    // Initialize LCD first (this sets up GPIOB pins)
    LCD_init(&cfg0);

    // Initialize TIM4 and TIM2 AFTER LCD to avoid GPIO conflict on PB6
    MX_TIM4_Init();
    //MX_TIM2_Init();  // Timer 2 for buzzer PWM uncomment if you want to use the buzzer in this demo
  
    // Initialize Joystick
    Joystick_Init(&joystick_cfg);
    
    // make screen black (0 in palette set in LCD.h)
    LCD_Fill_Buffer(0);
    LCD_Refresh(&cfg0);

    // Startup animation
    LCD_printString("Finite",  20, 30, 1, 5);
    LCD_Refresh(&cfg0);
    HAL_Delay(200);
    LCD_printString("State",  20, 90, 1, 5);
    LCD_Refresh(&cfg0);
    HAL_Delay(200);
    LCD_printString("Machine",  20, 150, 1, 5);
    LCD_Refresh(&cfg0);
    HAL_Delay(1000);

    // Display instructions
    LCD_Fill_Buffer(0);
    LCD_printString("Press Joystk", 5, 30, 1, 3);
    LCD_printString("to change", 30, 80, 1, 3);
    LCD_printString("STATE", 50, 130, 1, 4);
    LCD_Refresh(&cfg0);
    HAL_Delay(2000);

    // Initialize PWM for LED control (can be used for state indication)
    PWM_Init(&pwm_cfg);
    PWM_SetFreq(&pwm_cfg, 1000);  // 1kHz PWM frequency
    PWM_SetDuty(&pwm_cfg, 0);     // Start with LED OFF
    
    // Ensure LD2 on PA5 starts OFF
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);

    printf("FSM Demo initialized. Current state: %s\n", state_names[current_state]);

    // Display initial state
    display_state_info();

    while (1)
    {
        // ===== FINITE STATE MACHINE MAIN LOOP =====
        // The key concept: We execute DIFFERENT code based on the CURRENT STATE
        // The same joystick input produces different outputs in each state!
        
        // Check if state has changed (flag set by interrupt)
        if (state_changed) {
            state_changed = 0;
            display_state_info();
            printf("Guess we doin %s now\n", state_names[current_state]);
            printf("State changed to: %s\n", state_names[current_state]);
        }
        
        // Read joystick input (SAME for all states)
        Joystick_Read(&joystick_cfg, &joystick_data);
        
        // Execute the appropriate handler based on CURRENT STATE
        // This is the core of the FSM - different behavior for each state
        switch (current_state) {
            case STATE_CIRCLES:
                handle_state_circles(&joystick_data);
                break;
            
            case STATE_RECTANGLES:
                handle_state_rectangles(&joystick_data);
                break;
            
            case STATE_LINES:
                handle_state_lines(&joystick_data);
                break;
            
            case STATE_SPRITES:
                handle_state_sprites(&joystick_data);
                break;
            
            default:
                current_state = STATE_CIRCLES;
                break;
        }
        
        // Small delay to prevent overwhelming the LCD
        HAL_Delay(50);
    }
}

// ===== STATE HANDLER FUNCTIONS =====

/**
 * @brief Display current state information on LCD
 * Shows the state name and brief instructions
 */
void display_state_info(void) {
    LCD_Fill_Buffer(0);
    
    // Display state name prominently
    LCD_printString("STATE:", 10, 10, 1, 3);
    LCD_printString((char*)state_names[current_state], 10, 60, 6, 4);
    
    // Display brief instructions for this state
    switch (current_state) {
        case STATE_CIRCLES:
            LCD_printString("X->Color", 10, 130, 1, 3);
            LCD_printString("Y->Size", 10, 170, 1, 3);
            break;
        
        case STATE_RECTANGLES:
            LCD_printString("Move", 30, 130, 1, 3);
            LCD_printString("Rectangle", 10, 170, 1, 3);
            break;
        
        case STATE_LINES:
            LCD_printString("Point", 30, 130, 1, 3);
            LCD_printString("Direction", 10, 170, 1, 3);
            break;
        
        case STATE_SPRITES:
            LCD_printString("Move", 30, 130, 1, 3);
            LCD_printString("Sprite", 20, 170, 1, 3);
            break;
    }
    
    LCD_Refresh(&cfg0);
    HAL_Delay(1000);  // Show state info for 1 second
}

/**
 * @brief STATE_CIRCLES handler - Draw circles with color and size control
 * Joystick X controls color (cycling through palette)
 * Joystick Y controls circle size
 * 
 * This demonstrates how the SAME input (joystick) produces DIFFERENT output in different states
 */
void handle_state_circles(Joystick_t* joy) {
    static uint8_t last_color = 2;
    static uint8_t last_radius = 20;
    
    // Map joystick X to color (2-9 for 8 colors)
    uint8_t color = (uint8_t)((joy->coord_mapped.x + 1.0f) * 4.0f) + 2;  // Range 2-9
    if (color > 9) color = 9;
    if (color < 2) color = 2;
    
    // Map joystick Y to radius (15-45 pixels)
    uint8_t radius = (uint8_t)((joy->coord_mapped.y + 1.0f) * 15.0f) + 15;
    if (radius > 45) radius = 45;
    if (radius < 15) radius = 15;
    
    // Only redraw if color or size changed significantly
    if (color != last_color || abs(radius - last_radius) > 3) {
        LCD_Fill_Buffer(0);
        
        // Draw ONE circle in center with color and size based on joystick
        LCD_Draw_Circle(120, 120, radius, color, 1);
        
        LCD_Refresh(&cfg0);
        
        last_color = color;
        last_radius = radius;
    }
}

/**
 * @brief STATE_RECTANGLES handler - Draw rectangles with position control
 * Joystick controls rectangle position on screen
 * 
 * This demonstrates how the SAME input (joystick) produces DIFFERENT output in different states
 */  
void handle_state_rectangles(Joystick_t* joy) {
    static int16_t last_x = 120;
    static int16_t last_y = 120;
    
    // Map joystick to screen position (keep away from edges)
    int16_t x = (int16_t)(joy->coord_mapped.x * 80.0f) + 120;  // Range 40-200
    int16_t y = (int16_t)(-joy->coord_mapped.y * 80.0f) + 120;  // Range 40-200
    
    // Only redraw if position changed significantly
    if (abs(x - last_x) > 4 || abs(y - last_y) > 4) {
        LCD_Fill_Buffer(0);
        
        // Draw ONE simple rectangle that follows the joystick
        LCD_Draw_Rect(x - 30, y - 30, 60, 60, 3, 1);
        
        LCD_Refresh(&cfg0);
        
        last_x = x;
        last_y = y;
    }
}

/**
 * @brief STATE_LINES handler - Draw lines from center based on joystick direction
 * Joystick X/Y position directly controls line direction and length
 * 
 * This demonstrates how the SAME input (joystick) produces DIFFERENT output in different states
 */
void handle_state_lines(Joystick_t* joy) {
    static float last_x = 0;
    static float last_y = 0;
    
    // Only redraw if joystick moved significantly
    if (fabsf(joy->coord_mapped.x - last_x) > 0.1f || fabsf(joy->coord_mapped.y - last_y) > 0.1f) {
        LCD_Fill_Buffer(0);
        
        // Draw center point
        LCD_Draw_Circle(120, 120, 5, 1, 1);
        
        if (joy->magnitude > 0.1f) {  // Only draw line if joystick is pushed
            // Use joystick X/Y directly - much simpler and more intuitive!
            // Right joystick = line goes right, Up joystick = line goes up
            int16_t end_x = 120 + (int16_t)(joy->coord_mapped.x * 90.0f);
            int16_t end_y = 120 - (int16_t)(joy->coord_mapped.y * 90.0f);  // Subtract Y (screen Y increases downward)
            
            // Draw ONE simple line that follows the joystick direction
            LCD_Draw_Line(120, 120, end_x, end_y, 2);
            
            // Draw small circle at end to show direction clearly
            LCD_Draw_Circle(end_x, end_y, 6, 4, 1);
        }
        
        LCD_Refresh(&cfg0);
        
        last_x = joy->coord_mapped.x;
        last_y = joy->coord_mapped.y;
    }
}

/**
 * @brief STATE_SPRITES handler - Move sprite around screen with joystick
 * Joystick direction (using Direction enum) controls sprite movement
 * 
 * This demonstrates how the SAME input (joystick) produces DIFFERENT output in different states
 * Uses discrete 8-direction input rather than continuous analog values
 */
void handle_state_sprites(Joystick_t* joy) {
    static int16_t sprite_x = 120;
    static int16_t sprite_y = 120;
    static Direction last_direction = CENTRE;
    
    // Movement step size in pixels
    const int16_t SPRITE_STEP_SIZE = 5;
    
    // Use the Direction enum for discrete 8-way movement
    Direction dir = joy->direction;
    
    // Only move when direction changes or is held (move every frame when pushed)
    if (dir != CENTRE) {
        // Move sprite based on direction
        switch(dir) {
            case N:  sprite_y -= SPRITE_STEP_SIZE; break;
            case NE: sprite_y -= SPRITE_STEP_SIZE; sprite_x += SPRITE_STEP_SIZE; break;
            case E:  sprite_x += SPRITE_STEP_SIZE; break;
            case SE: sprite_y += SPRITE_STEP_SIZE; sprite_x += SPRITE_STEP_SIZE; break;
            case S:  sprite_y += SPRITE_STEP_SIZE; break;
            case SW: sprite_y += SPRITE_STEP_SIZE; sprite_x -= SPRITE_STEP_SIZE; break;
            case W:  sprite_x -= SPRITE_STEP_SIZE; break;
            case NW: sprite_y -= SPRITE_STEP_SIZE; sprite_x -= SPRITE_STEP_SIZE; break;
            default: break;
        }
        
        // Keep sprite on screen (10x10 sprite scaled 2x = 20x20)
        if (sprite_x < 20) sprite_x = 20;
        if (sprite_x > 220) sprite_x = 220;
        if (sprite_y < 20) sprite_y = 20;
        if (sprite_y > 220) sprite_y = 220;
    }
    
    // Redraw screen
    LCD_Fill_Buffer(0);
    
    // Draw the face sprite with color and scaling (color=4, scale=3x)
    LCD_Draw_Sprite_Colour_Scaled(sprite_x - 15, sprite_y - 15, 10, 10, (uint8_t*)Face, 4, 3);
    
    LCD_Refresh(&cfg0);
    
    last_direction = dir;
}

// ===== Interrupt Callback =====

/**
  * @brief EXTI line detection callback - FSM State Transition
  * @param GPIO_Pin: Specifies which GPIO pin triggered the interrupt
  * 
  * @note This is the key to the FSM: when the button is pressed, we change the state!
  *       The interrupt changes 'current_state', which causes the main loop to execute
  *       a different handler function. This is how external events trigger state transitions.
  *       
  *       IMPORTANT: We keep ISRs SHORT and SIMPLE - just change the state variable and
  *       set a flag. The main loop handles everything else (display updates, etc).
  *       Never use HAL_Delay() in an interrupt handler as it can cause the system to hang!
  */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  static uint32_t btn3_last_interrupt_time = 0;
  uint32_t current_time = HAL_GetTick();
  
  // Check if joystick button (BTN3) was pressed
  if (GPIO_Pin == BTN3_Pin)
  {
    // Debouncing: ignore interrupts that happen too quickly (within 200ms)
    if ((current_time - btn3_last_interrupt_time) > DEBOUNCE_DELAY)
    {
      btn3_last_interrupt_time = current_time;
      
      // STATE TRANSITION: Move to next state (wraps back to 0 after last state)
      // The (FSM_State_t) cast is needed because arithmetic operations (+, %) 
      // return an integer type, so we must explicitly cast back to enum type
      current_state = (FSM_State_t)((current_state + 1) % STATE_COUNT);
      
      // Set flag to tell main loop that state has changed
      state_changed = 1;
      
    }
  }
}

// ==== AUTO-GENERATED STM32 FUNCTIONS ====
// DO NOT EDIT UNLESS YOU KNOW WHAT YOU ARE DOING! 


/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 10;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};

  /** Initializes the peripherals clock
  */
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RNG|RCC_PERIPHCLK_ADC;
  PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
  PeriphClkInit.RngClockSelection = RCC_RNGCLKSOURCE_PLLSAI1;
  PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSI;
  PeriphClkInit.PLLSAI1.PLLSAI1M = 1;
  PeriphClkInit.PLLSAI1.PLLSAI1N = 8;
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV4;
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK|RCC_PLLSAI1_ADC1CLK;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
  {
    Error_Handler();
  }
}



/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
